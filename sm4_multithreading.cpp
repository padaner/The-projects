#include<iostream>
#include<bitset>
#include<string>
#include <typeinfo>
#include <thread>
#include <mutex>
using namespace std;

mutex mu;
const int size0 = 8;
unsigned long ming[size0] = { 0x12a3203a ,0xa56f2bc2 ,0xa85fed25,0x1a32c358,0x12345678,0x9abcdeff,0xffedcba9,0x87654321 };
string result[size0];
string X[36];
string K[36];
string RK[32];
bitset<32> mk0(0x456bcfe5);
bitset<32> mk1(0x1235efbc);
bitset<32> mk2(0xace52541);
bitset<32> mk3(0xac52384d);
bitset<32> fk0(0xA3B1BAC6);
bitset<32> fk1(0x56AA3350);
bitset<32> fk2(0x677D9197);
bitset<32> fk3(0xB27022DC);


int s[256] = {
	0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
	0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
	0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
	0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
	0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
	0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
	0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
	0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
	0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
	0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
	0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
	0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
	0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
	0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
	0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
	0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};
long long CK[32] = {
	0x00070E15,0x1C232A31,0x383F464D,0x545B6269,
	0x70777E85,0x8C939AA1,0xA8AFB6BD,0xC4CBD2D9,
	0xE0E7EEF5,0xFC030A11,0x181F262D,0x343B4249,
	0x50575E65,0x6C737A81,0x888F969D,0xA4ABB2B9,
	0xC0C7CED5,0xDCE3EAF1,0xF8FF060D,0x141B2229,
	0x30373E45,0x4C535A61,0x686F767D,0x848B9299,
	0xA0A7AEB5,0xBCC3CAD1,0xD8DFE6ED,0xF4FB0209,
	0x10171E25,0x2C333A41,0x484F565D,0x646B7279
};

string yihuo(string a, string b)
{
	bitset<32> x(a);
	bitset<32> y(b);
	bitset<32> z;
	z = x ^ y;
	string r;
	r = z.to_string();
	return r;
}
string zuoyi(int a, bitset<32> x)
{
	bitset<32> y;
	y = x << a;
	for (int i = 0; i < a; i++)
	{
		y[i] = x[32 - a + i];
	}
	string r;
	r = y.to_string();
	return r;
}


//T函数
//n为0时加密密文，n为1时加密秘钥
string T(bitset<32> x, int n)
{
	bitset<4> a0;
	bitset<4> a1;
	bitset<4> a2;
	bitset<4> a3;
	bitset<4> a4;
	bitset<4> a5;
	bitset<4> a6;
	bitset<4> a7;
	bitset<32> y;
	for (int i = 0; i < 4; i++)
	{

		a7[i] = x[i];
		a6[i] = x[i + 4];
		a5[i] = x[i + 8];
		a4[i] = x[i + 12];
		a3[i] = x[i + 16];
		a2[i] = x[i + 20];
		a1[i] = x[i + 24];
		a0[i] = x[i + 28];
	}
	int b0, b1, b2, b3, b4, b5, b6, b7,
		c0, c1, c2, c3;
	//转换成S盒对应的内容
	b0 = a0.to_ulong();
	b1 = a1.to_ulong();
	b2 = a2.to_ulong();
	b3 = a3.to_ulong();
	b4 = a4.to_ulong();
	b5 = a5.to_ulong();
	b6 = a6.to_ulong();
	b7 = a7.to_ulong();
	c0 = s[b0 * 16 + b1];
	c1 = s[b2 * 16 + b3];
	c2 = s[b4 * 16 + b5];
	c3 = s[b6 * 16 + b7];
	bitset<8> d0(c0);
	bitset<8> d1(c1);
	bitset<8> d2(c2);
	bitset<8> d3(c3);
	for (int i = 0; i < 8; i++)
	{
		y[i] = d3[i];
		y[i + 8] = d2[i];
		y[i + 16] = d1[i];
		y[i + 24] = d0[i];
	}

	//L函数
	if (n == 0)
	{
		string y0, y1, y2, y3;
		y0 = zuoyi(2, y);
		y1 = zuoyi(10, y);
		y2 = zuoyi(18, y);
		y3 = zuoyi(24, y);
		bitset<32> y00(y0);
		bitset<32> y11(y1);
		bitset<32> y22(y2);
		bitset<32> y33(y3);
		y = y ^ y00 ^ y11 ^ y22 ^ y33;
	}
	if (n == 1)
	{
		string y0, y1;
		y0 = zuoyi(13, y);
		y1 = zuoyi(23, y);
		bitset<32> y00(y0);
		bitset<32> y11(y1);
		y = y ^ y00 ^ y11;
	}
	string r;
	r = y.to_string();
	return r;
}

//生成秘钥
void ckey()
{
	bitset<32> k0 = mk0 ^ fk0;
	bitset<32> k1 = mk1 ^ fk1;
	bitset<32> k2 = mk2 ^ fk2;
	bitset<32> k3 = mk3 ^ fk3;
	K[0] = k0.to_string();
	K[1] = k1.to_string();
	K[2] = k2.to_string();
	K[3] = k3.to_string();
	for (int i = 0; i < 32; i++)
	{
		bitset<32> y1(K[i + 1]);
		bitset<32> y2(K[i + 2]);
		bitset<32> y3(K[i + 3]);
		bitset<32> ck(CK[i]);
		bitset<32> ru = y1 ^ y2 ^ y3 ^ ck;
		string Chu;
		Chu = T(ru, 1);
		K[i + 4] = yihuo(K[i], Chu);
		RK[i] = K[i + 4];
	}
}

void F(string x0,string x1,string x2,string x3)//加密
{
	X[0] = x0;
	X[1] = x1;
	X[2] = x2;
	X[3] = x3;
	int i;
	for (i = 0; i < 32; i++)
	{
		bitset<32> y1(X[i + 1]);
		bitset<32> y2(X[i + 2]);
		bitset<32> y3(X[i + 3]);
		bitset<32> rk(RK[i]);
		bitset<32> ru = y1 ^ y2 ^ y3 ^ rk;
		string Chu = T(ru, 0);
		
		X[i + 4] = yihuo(Chu, X[i]);
	}
}


void sm4(int begin,int end)
{
	mu.lock();
	bitset<32> m0(ming[begin]);
	bitset<32> m1(ming[begin+1]);
	bitset<32> m2(ming[begin+2]);
	bitset<32> m3(ming[begin+3]);
	string x0 = m0.to_string();
	string x1 = m1.to_string();
	string x2 = m2.to_string();
	string x3 = m3.to_string();
	ckey();
	F(x0,x1,x2,x3);
	result[begin] = X[35];
	result[begin+ 1] = X[34];
	result[begin+ 2] = X[33];
	result[begin + 3] = X[32];
	mu.unlock();
}

void multi_thread() {
	int cpu_num = 2;//16
	int use_cpu_num = cpu_num;
	int split_num = 3;
	int k1 = 0, k2 = split_num;// k1,k2切分数组
	thread* th = new thread[use_cpu_num + 1];
	for (int i = 0; i < use_cpu_num; i++) {
		th[i] = thread(sm4, k1, k2);
		k1 = k2 + 1;
		k2 += split_num;
		if (k2 >=size0)
			k2 = size0;
	}
	for (int i = 0; i < use_cpu_num; i++)
		th[i].join();
}
int main()
{
	float t1 = clock();
	multi_thread();
	for (int i = 0; i < size0; i++)
		cout << result[i] << endl;
	float t2 = clock();
	cout << "运行所需时间为：" << (t2 - t1) / (CLOCKS_PER_SEC);
	return 0;
}
